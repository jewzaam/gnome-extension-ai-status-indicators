// Generated by Cursor
import GObject from 'gi://GObject';
import St from 'gi://St';
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

import {Extension, gettext as _} from 'resource:///org/gnome/shell/extensions/extension.js';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import * as PanelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';

const StatusIndicator = GObject.registerClass(
class StatusIndicator extends St.BoxLayout {
    _init(name, readyIcon, workingIcon, waitingIcon, showLabel) {
        super._init({
            style_class: 'status-indicator',
            reactive: true,
            can_focus: true,
            track_hover: true,
            vertical: false
        });

        this._name = name;
        this._readyIcon = readyIcon;
        this._workingIcon = workingIcon;
        this._waitingIcon = waitingIcon;
        this._showLabel = showLabel;
        this._status = 'ready'; // 'ready', 'working', 'waiting'

        this._iconLabel = new St.Label({
            text: this._readyIcon,
            y_align: St.Align.MIDDLE,
            style_class: 'status-indicator-icon'
        });

        this.add_child(this._iconLabel);

        if (this._showLabel) {
            this._textLabel = new St.Label({
                text: this._name,
                y_align: St.Align.MIDDLE,
                style_class: 'status-indicator-label'
            });
            this.add_child(this._textLabel);
        }

        // Set tooltip to show indicator name
        this.set_tooltip_text(this._name);
    }

    setStatus(status) {
        this._status = status;
        let icon;
        switch (status) {
            case 'working':
                icon = this._workingIcon;
                break;
            case 'waiting':
                icon = this._waitingIcon;
                break;
            case 'ready':
            default:
                icon = this._readyIcon;
                break;
        }
        this._iconLabel.set_text(icon);
    }

    // Keep backward compatibility
    setWorking(isWorking) {
        this.setStatus(isWorking ? 'working' : 'ready');
    }

    updateConfig(name, readyIcon, workingIcon, waitingIcon, showLabel) {
        this._name = name;
        this._readyIcon = readyIcon;
        this._workingIcon = workingIcon;
        this._waitingIcon = waitingIcon;
        
        // Update current display based on current status
        this.setStatus(this._status);
        
        if (this._showLabel !== showLabel) {
            this._showLabel = showLabel;
            if (showLabel && !this._textLabel) {
                this._textLabel = new St.Label({
                    text: this._name,
                    y_align: St.Align.MIDDLE,
                    style_class: 'status-indicator-label'
                });
                this.add_child(this._textLabel);
            } else if (!showLabel && this._textLabel) {
                this.remove_child(this._textLabel);
                this._textLabel = null;
            }
        }
        
        if (this._textLabel) {
            this._textLabel.set_text(this._name);
        }

        // Update tooltip with new name
        this.set_tooltip_text(this._name);
    }
});

const StatusWidget = GObject.registerClass(
class StatusWidget extends PanelMenu.Button {
    _init() {
        super._init(0.0, _("AI Status Indicators"));

        this._container = new St.BoxLayout({
            style_class: 'status-widget-container',
            vertical: false
        });

        this.add_child(this._container);
        this._indicators = new Map();
    }

    addIndicator(id, name, readyIcon = '✅', workingIcon = '⚠️', waitingIcon = '⛔', showLabel = false) {
        if (this._indicators.has(id)) {
            return;
        }

        const indicator = new StatusIndicator(name, readyIcon, workingIcon, waitingIcon, showLabel);
        this._indicators.set(id, indicator);
        this._container.add_child(indicator);
        this._updateVisibility();
    }

    removeIndicator(id) {
        const indicator = this._indicators.get(id);
        if (indicator) {
            this._container.remove_child(indicator);
            this._indicators.delete(id);
            this._updateVisibility();
        }
    }

    updateIndicator(id, name, readyIcon, workingIcon, waitingIcon, showLabel) {
        const indicator = this._indicators.get(id);
        if (indicator) {
            indicator.updateConfig(name, readyIcon, workingIcon, waitingIcon, showLabel);
        }
    }

    setIndicatorStatus(id, status) {
        const indicator = this._indicators.get(id);
        if (indicator) {
            if (typeof status === 'boolean') {
                // Backward compatibility: boolean means working/ready
                indicator.setWorking(status);
            } else {
                // New string-based status
                indicator.setStatus(status);
            }
        }
    }

    clearIndicators() {
        for (const [id, indicator] of this._indicators) {
            this._container.remove_child(indicator);
        }
        this._indicators.clear();
        this._updateVisibility();
    }

    _updateVisibility() {
        this.visible = this._indicators.size > 0;
    }
});

export default class StatusWidgetExtension extends Extension {
    constructor(metadata) {
        super(metadata);
        this._widget = null;
        this._settings = null;
        this._settingsConnections = [];
        this._applicationLimits = new Map(); // Track indicators per application
        this._lastUpdateTime = new Map(); // Rate limiting
    }

    enable() {
        this._settings = this.getSettings();
        this._widget = new StatusWidget();
        
        // Load initial indicators
        this._loadIndicators();
        
        // Connect to settings changes
        this._settingsConnections = [
            this._settings.connect('changed::indicators', () => this._loadIndicators()),
            this._settings.connect('changed::show-labels', () => this._loadIndicators()),
            this._settings.connect('changed::position', () => this._updatePosition())
        ];
        
        // Add to panel
        this._updatePosition();
        
        // Create D-Bus interface for external control
        this._createDBusInterface();
    }

    disable() {
        // Disconnect settings
        this._settingsConnections.forEach(connection => {
            this._settings.disconnect(connection);
        });
        this._settingsConnections = [];
        
        // Remove from panel
        if (this._widget) {
            this._widget.destroy();
            this._widget = null;
        }
        
        // Clean up D-Bus
        if (this._dbusImpl) {
            this._dbusImpl.unexport();
            this._dbusImpl = null;
        }
        
        // Clear security tracking
        this._applicationLimits.clear();
        this._lastUpdateTime.clear();
        
        this._settings = null;
    }

    _loadIndicators() {
        if (!this._widget || !this._settings) {
            return;
        }

        const indicatorsJson = this._settings.get_string('indicators');
        const showLabels = this._settings.get_boolean('show-labels');
        
        let indicators = [];
        try {
            indicators = JSON.parse(indicatorsJson);
        } catch (e) {
            console.error('Failed to parse indicators configuration:', e);
            return;
        }

        // Clear existing indicators
        this._widget.clearIndicators();

        // Add configured indicators
        indicators.forEach(indicator => {
            this._widget.addIndicator(
                indicator.id,
                indicator.name,
                indicator.readyIcon || '✅',
                indicator.workingIcon || '⚠️',
                indicator.waitingIcon || '⛔',
                showLabels
            );
        });
    }

    _updatePosition() {
        if (!this._widget) {
            return;
        }

        // Remove from current position
        const boxes = [
            Main.panel._leftBox,
            Main.panel._centerBox,
            Main.panel._rightBox
        ];
        boxes.forEach(box => {
            if (box.get_children().includes(this._widget)) {
                box.remove_child(this._widget);
            }
        });

        // Add to new position
        const position = this._settings.get_string('position');
        let targetBox;
        let index = -1;

        // The original code uses index = -1 for 'left' and 'center', and index = 0 for 'right'.
        // In St.BoxLayout, index = -1 means "append at the end", and index = 0 means "insert at the beginning".
        // This is likely to ensure the widget appears at the far right in the right box (which is the default GNOME convention),
        // and at the end in left/center boxes (so it doesn't push out other items).
        // For clarity, let's add a comment and make the intent explicit:

        switch (position) {
            case 'left':
                targetBox = Main.panel._leftBox;
                // Insert at end so it appears rightmost in the left box
                index = -1;
                break;
            case 'center':
                targetBox = Main.panel._centerBox;
                // Insert at end so it appears rightmost in the center box
                index = -1;
                break;
            case 'right':
            default:
                targetBox = Main.panel._rightBox;
                // Insert at beginning so it appears leftmost in the right box (GNOME convention)
                index = 0;
                break;
        }

        targetBox.insert_child_at_index(this._widget, index);
    }

    _createDBusInterface() {
        const interfaceXml = `
        <node>
            <interface name="org.gnome.shell.extensions.StatusWidget">
                <method name="SetIndicatorStatus">
                    <arg type="s" direction="in" name="id"/>
                    <arg type="s" direction="in" name="status"/>
                </method>
                <method name="AddIndicator">
                    <arg type="s" direction="in" name="id"/>
                    <arg type="s" direction="in" name="name"/>
                    <arg type="s" direction="in" name="readyIcon"/>
                    <arg type="s" direction="in" name="workingIcon"/>
                    <arg type="s" direction="in" name="waitingIcon"/>
                </method>
                <method name="RemoveIndicator">
                    <arg type="s" direction="in" name="id"/>
                </method>
            </interface>
        </node>`;

        this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(interfaceXml, this);
        this._dbusImpl.export(Gio.DBus.session, '/org/gnome/shell/extensions/StatusWidget');
    }

    _validateInput(text, maxLength = 50) {
        if (!text || typeof text !== 'string') {
            return '';
        }
        
        // Remove potentially dangerous characters and limit length
        const sanitized = text
            .replace(/[<>&"']/g, '') // Remove HTML/XML characters
            .replace(/[\x00-\x1F\x7F]/g, '') // Remove control characters
            .slice(0, maxLength);
            
        return sanitized;
    }

    _getCallerInfo() {
        // In a real implementation, we'd get the D-Bus sender
        // For now, we'll use a simple approach
        const stack = new Error().stack;
        const caller = stack ? stack.split('\n')[3] : 'unknown';
        return caller.includes('example-client') ? 'example-client' : 'unknown-app';
    }

    _checkRateLimit(appId) {
        const now = Date.now();
        const lastUpdate = this._lastUpdateTime.get(appId) || 0;
        const rateLimitMs = this._settings.get_int('rate-limit-ms');
        
        if (now - lastUpdate < rateLimitMs) {
            if (this._settings.get_boolean('enable-logging')) {
                console.warn(`Rate limit exceeded for application: ${appId}`);
            }
            return false;
        }
        
        this._lastUpdateTime.set(appId, now);
        return true;
    }

    _checkIndicatorLimit(appId) {
        const currentCount = this._applicationLimits.get(appId) || 0;
        const maxIndicators = this._settings.get_int('max-indicators-per-app');
        
        if (currentCount >= maxIndicators) {
            if (this._settings.get_boolean('enable-logging')) {
                console.warn(`Indicator limit exceeded for application: ${appId} (${currentCount}/${maxIndicators})`);
            }
            return false;
        }
        
        return true;
    }

    // D-Bus methods with security validation
    SetIndicatorStatus(id, status) {
        if (!this._widget) return;
        
        const appId = this._getCallerInfo();
        
        // Rate limiting
        if (!this._checkRateLimit(appId)) {
            return;
        }
        
        // Input validation
        const validId = this._validateInput(id, 30);
        const validStatus = this._validateInput(status, 20);
        
        // Only allow valid status values
        if (!['ready', 'working', 'waiting'].includes(validStatus)) {
            if (this._settings.get_boolean('enable-logging')) {
                console.warn(`Invalid status value: ${status} from ${appId}`);
            }
            return;
        }
        
        this._widget.setIndicatorStatus(validId, validStatus);
    }

    AddIndicator(id, name, readyIcon = '✅', workingIcon = '⚠️', waitingIcon = '⛔') {
        if (!this._widget) return;
        
        const appId = this._getCallerInfo();
        
        // Rate limiting
        if (!this._checkRateLimit(appId)) {
            return;
        }
        
        // Check indicator limit per application
        if (!this._checkIndicatorLimit(appId)) {
            return;
        }
        
        // Input validation
        const validId = this._validateInput(id, 30);
        const validName = this._validateInput(name, 50);
        const validReadyIcon = this._validateInput(readyIcon, 10);
        const validWorkingIcon = this._validateInput(workingIcon, 10);
        const validWaitingIcon = this._validateInput(waitingIcon, 10);
        
        // Ensure we have valid inputs
        if (!validId || !validName) {
            if (this._settings.get_boolean('enable-logging')) {
                console.warn(`Invalid parameters for AddIndicator from ${appId}`);
            }
            return;
        }
        
        // Track indicator count for this application
        const currentCount = this._applicationLimits.get(appId) || 0;
        this._applicationLimits.set(appId, currentCount + 1);
        
        const showLabels = this._settings.get_boolean('show-labels');
        this._widget.addIndicator(validId, validName, validReadyIcon, validWorkingIcon, validWaitingIcon, showLabels);
        
        if (this._settings.get_boolean('enable-logging')) {
            console.log(`Added indicator '${validName}' (${validId}) from ${appId}`);
        }
    }

    RemoveIndicator(id) {
        if (!this._widget) return;
        
        const appId = this._getCallerInfo();
        
        // Rate limiting
        if (!this._checkRateLimit(appId)) {
            return;
        }
        
        // Input validation
        const validId = this._validateInput(id, 30);
        
        if (!validId) {
            if (this._settings.get_boolean('enable-logging')) {
                console.warn(`Invalid indicator ID for RemoveIndicator from ${appId}`);
            }
            return;
        }
        
        // Decrease count for this application
        const currentCount = this._applicationLimits.get(appId) || 0;
        if (currentCount > 0) {
            this._applicationLimits.set(appId, currentCount - 1);
        }
        
        this._widget.removeIndicator(validId);
        
        if (this._settings.get_boolean('enable-logging')) {
            console.log(`Removed indicator ${validId} from ${appId}`);
        }
    }
} 