// Generated by Cursor
import Adw from 'gi://Adw';
import Gtk from 'gi://Gtk';
import Gio from 'gi://Gio';
import GObject from 'gi://GObject';

import {ExtensionPreferences, gettext as _} from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';

const IndicatorRow = GObject.registerClass(
    class IndicatorRow extends Adw.ActionRow {
        _init(indicator, onUpdate, onDelete) {
            super._init({
                title: indicator.name,
                subtitle: `Ready: ${indicator.readyIcon} | Working: ${indicator.workingIcon} | Waiting: ${indicator.waitingIcon}`
            });

            this._indicator = indicator;
            this._onUpdate = onUpdate;
            this._onDelete = onDelete;

            // Delete button
            const deleteButton = new Gtk.Button({
                icon_name: 'edit-delete-symbolic',
                css_classes: ['flat', 'circular'],
                valign: Gtk.Align.CENTER
            });
            deleteButton.connect('clicked', () => this._onDelete(this._indicator.id));
            this.add_suffix(deleteButton);

            // Edit button
            const editButton = new Gtk.Button({
                icon_name: 'edit-symbolic',
                css_classes: ['flat', 'circular'],
                valign: Gtk.Align.CENTER
            });
            editButton.connect('clicked', () => this._showEditDialog());
            this.add_suffix(editButton);
        }

        _showEditDialog() {
            const dialog = new Gtk.Dialog({
                title: _('Edit Indicator'),
                modal: true,
                transient_for: this.get_root()
            });

            const contentArea = dialog.get_content_area();
            contentArea.set_spacing(12);
            contentArea.set_margin_top(12);
            contentArea.set_margin_bottom(12);
            contentArea.set_margin_start(12);
            contentArea.set_margin_end(12);

            // Name entry
            const nameLabel = new Gtk.Label({label: _('Name:'), xalign: 0});
            const nameEntry = new Gtk.Entry({text: this._indicator.name});
            contentArea.append(nameLabel);
            contentArea.append(nameEntry);

            // Ready icon entry
            const readyLabel = new Gtk.Label({label: _('Ready Icon:'), xalign: 0});
            const readyEntry = new Gtk.Entry({text: this._indicator.readyIcon});
            contentArea.append(readyLabel);
            contentArea.append(readyEntry);

            // Working icon entry
            const workingLabel = new Gtk.Label({label: _('Working Icon:'), xalign: 0});
            const workingEntry = new Gtk.Entry({text: this._indicator.workingIcon});
            contentArea.append(workingLabel);
            contentArea.append(workingEntry);

            // Waiting icon entry
            const waitingLabel = new Gtk.Label({label: _('Waiting Icon:'), xalign: 0});
            const waitingEntry = new Gtk.Entry({text: this._indicator.waitingIcon});
            contentArea.append(waitingLabel);
            contentArea.append(waitingEntry);

            // Buttons
            dialog.add_button(_('Cancel'), Gtk.ResponseType.CANCEL);
            dialog.add_button(_('Save'), Gtk.ResponseType.OK);

            dialog.connect('response', (dialog, response) => {
                if (response === Gtk.ResponseType.OK) {
                    // Update the indicator object
                    this._indicator.name = nameEntry.get_text();
                    this._indicator.readyIcon = readyEntry.get_text();
                    this._indicator.workingIcon = workingEntry.get_text();
                    this._indicator.waitingIcon = waitingEntry.get_text();

                    // Update the UI
                    this.set_title(this._indicator.name);
                    this.set_subtitle(`Ready: ${this._indicator.readyIcon} | Working: ${this._indicator.workingIcon} | Waiting: ${this._indicator.waitingIcon}`);

                    // Save the updated indicator to settings
                    this._onUpdate(this._indicator);
                }
                dialog.destroy();
            });

            dialog.show();
        }
    });

export default class StatusWidgetPreferences extends ExtensionPreferences {
    fillPreferencesWindow(window) {
        const settings = this.getSettings();

        // Main page
        const page = new Adw.PreferencesPage({
            title: _('AI Status Indicators'),
            icon_name: 'applications-utilities-symbolic'
        });

        // General group
        const generalGroup = new Adw.PreferencesGroup({
            title: _('General')
        });

        // Position setting
        const positionRow = new Adw.ComboRow({
            title: _('Position'),
            subtitle: _('Position of the AI status indicators in the top bar'),
            model: new Gtk.StringList({strings: [
                _('Left'),
                _('Center'),
                _('Right')
            ]})
        });

        const position = settings.get_string('position');
        switch (position) {
        case 'left':
            positionRow.set_selected(0);
            break;
        case 'center':
            positionRow.set_selected(1);
            break;
        case 'right':
        default:
            positionRow.set_selected(2);
            break;
        }

        positionRow.connect('notify::selected', () => {
            const selected = positionRow.get_selected();
            const positions = ['left', 'center', 'right'];
            settings.set_string('position', positions[selected]);
        });

        generalGroup.add(positionRow);

        // Show labels setting
        const showLabelsRow = new Adw.SwitchRow({
            title: _('Show Labels'),
            subtitle: _('Show text labels next to indicators')
        });

        settings.bind('show-labels', showLabelsRow, 'active', Gio.SettingsBindFlags.DEFAULT);
        generalGroup.add(showLabelsRow);

        page.add(generalGroup);

        // Security group
        const securityGroup = new Adw.PreferencesGroup({
            title: _('Security')
        });

        // Max indicators per app
        const maxIndicatorsRow = new Adw.SpinRow({
            title: _('Max Indicators per App'),
            subtitle: _('Maximum number of indicators each application can create'),
            adjustment: new Gtk.Adjustment({
                lower: 1,
                upper: 20,
                step_increment: 1,
                page_increment: 5,
                value: settings.get_int('max-indicators-per-app')
            })
        });

        maxIndicatorsRow.connect('notify::value', () => {
            settings.set_int('max-indicators-per-app', maxIndicatorsRow.get_value());
        });

        securityGroup.add(maxIndicatorsRow);

        // Rate limit
        const rateLimitRow = new Adw.SpinRow({
            title: _('Rate Limit (ms)'),
            subtitle: _('Minimum time between D-Bus calls from the same application'),
            adjustment: new Gtk.Adjustment({
                lower: 50,
                upper: 5000,
                step_increment: 50,
                page_increment: 100,
                value: settings.get_int('rate-limit-ms')
            })
        });

        rateLimitRow.connect('notify::value', () => {
            settings.set_int('rate-limit-ms', rateLimitRow.get_value());
        });

        securityGroup.add(rateLimitRow);

        // Enable logging
        const enableLoggingRow = new Adw.SwitchRow({
            title: _('Enable Security Logging'),
            subtitle: _('Log D-Bus calls and security events for monitoring')
        });

        settings.bind('enable-logging', enableLoggingRow, 'active', Gio.SettingsBindFlags.DEFAULT);
        securityGroup.add(enableLoggingRow);

        page.add(securityGroup);

        // Indicators group
        const indicatorsGroup = new Adw.PreferencesGroup({
            title: _('Indicators')
        });

        // Add indicator button
        const addButton = new Gtk.Button({
            label: _('Add Indicator'),
            css_classes: ['suggested-action'],
            halign: Gtk.Align.CENTER,
            margin_top: 12,
            margin_bottom: 12
        });

        addButton.connect('clicked', () => this._showAddDialog(window, settings, indicatorsGroup));
        indicatorsGroup.add(addButton);

        // Load existing indicators
        this._loadIndicators(settings, indicatorsGroup);

        page.add(indicatorsGroup);
        window.add(page);

        // Connect to settings changes
        settings.connect('changed::indicators', () => {
            this._loadIndicators(settings, indicatorsGroup);
        });
    }

    _loadIndicators(settings, group) {
        // Remove existing indicator rows (but keep the add button)
        const children = [];
        for (let child = group.get_first_child(); child; child = child.get_next_sibling()) {
            children.push(child);
        }

        children.forEach(child => {
            if (child instanceof IndicatorRow) {
                group.remove(child);
            }
        });

        // Add current indicators
        const indicatorsJson = settings.get_string('indicators');
        let indicators = [];
        try {
            indicators = JSON.parse(indicatorsJson);
        } catch (e) {
            console.error('Failed to parse indicators:', e);
            return;
        }

        indicators.forEach(indicator => {
            const row = new IndicatorRow(
                indicator,
                (indicator) => this._saveIndicators(settings, indicator),
                (id) => this._deleteIndicator(settings, id)
            );
            group.add(row);
        });
    }

    _showAddDialog(window, settings, _group) {
        const dialog = new Gtk.Dialog({
            title: _('Add Indicator'),
            modal: true,
            transient_for: window
        });

        const contentArea = dialog.get_content_area();
        contentArea.set_spacing(12);
        contentArea.set_margin_top(12);
        contentArea.set_margin_bottom(12);
        contentArea.set_margin_start(12);
        contentArea.set_margin_end(12);

        // Name entry
        const nameLabel = new Gtk.Label({label: _('Name:'), xalign: 0});
        const nameEntry = new Gtk.Entry({placeholder_text: _('e.g., Cursor AI')});
        contentArea.append(nameLabel);
        contentArea.append(nameEntry);

        // Ready icon entry
        const readyLabel = new Gtk.Label({label: _('Ready Icon:'), xalign: 0});
        const readyEntry = new Gtk.Entry({text: '✅', placeholder_text: _('e.g., ✅')});
        contentArea.append(readyLabel);
        contentArea.append(readyEntry);

        // Working icon entry
        const workingLabel = new Gtk.Label({label: _('Working Icon:'), xalign: 0});
        const workingEntry = new Gtk.Entry({text: '⚠️', placeholder_text: _('e.g., ⚠️')});
        contentArea.append(workingLabel);
        contentArea.append(workingEntry);

        // Waiting icon entry
        const waitingLabel = new Gtk.Label({label: _('Waiting Icon:'), xalign: 0});
        const waitingEntry = new Gtk.Entry({text: '⛔', placeholder_text: _('e.g., ⛔')});
        contentArea.append(waitingLabel);
        contentArea.append(waitingEntry);

        // Buttons
        dialog.add_button(_('Cancel'), Gtk.ResponseType.CANCEL);
        dialog.add_button(_('Add'), Gtk.ResponseType.OK);

        dialog.connect('response', (dialog, response) => {
            if (response === Gtk.ResponseType.OK) {
                const name = nameEntry.get_text();
                const readyIcon = readyEntry.get_text() || '✅';
                const workingIcon = workingEntry.get_text() || '⚠️';
                const waitingIcon = waitingEntry.get_text() || '⛔';

                if (name.trim()) {
                    this._addIndicator(settings, name, readyIcon, workingIcon, waitingIcon);
                }
            }
            dialog.destroy();
        });

        dialog.show();
    }

    _addIndicator(settings, name, readyIcon, workingIcon, waitingIcon) {
        const indicatorsJson = settings.get_string('indicators');
        let indicators = [];
        try {
            indicators = JSON.parse(indicatorsJson);
        } catch (e) {
            console.error('Failed to parse indicators:', e);
        }

        const id = Date.now().toString();
        indicators.push({
            id: id,
            name: name,
            readyIcon: readyIcon,
            workingIcon: workingIcon,
            waitingIcon: waitingIcon
        });

        settings.set_string('indicators', JSON.stringify(indicators));
    }

    _deleteIndicator(settings, id) {
        const indicatorsJson = settings.get_string('indicators');
        let indicators = [];
        try {
            indicators = JSON.parse(indicatorsJson);
        } catch (e) {
            console.error('Failed to parse indicators:', e);
            return;
        }

        const filteredIndicators = indicators.filter(indicator => indicator.id !== id);
        settings.set_string('indicators', JSON.stringify(filteredIndicators));
    }

    _saveIndicators(settings, editedIndicator) {
        // This method is called when an indicator is edited
        // We need to update the specific indicator in the settings

        const indicatorsJson = settings.get_string('indicators');
        let indicators = [];
        try {
            indicators = JSON.parse(indicatorsJson);
        } catch (e) {
            console.error('Failed to parse indicators:', e);
            return;
        }

        // Find and update the edited indicator
        const index = indicators.findIndex(indicator => indicator.id === editedIndicator.id);
        if (index !== -1) {
            indicators[index] = editedIndicator;
            settings.set_string('indicators', JSON.stringify(indicators));
        }
    }
}
