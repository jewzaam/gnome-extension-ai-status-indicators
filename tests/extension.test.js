// Generated by Cursor
// Integration tests for the extension
const Extension = global.Extension;
const Main = global.Main;
const Gio = global.imports.gi.Gio;

// Mock Extension class for testing
class MockStatusWidgetExtension extends Extension {
    constructor(metadata = {}) {
        super(metadata);
        this._widget = null;
        this._settings = null;
        this._settingsConnections = [];
        this._dbusImpl = null;
    }

    enable() {
        this._settings = this.getSettings();
        this._widget = {
            destroy: jest.fn(),
            clearIndicators: jest.fn(),
            addIndicator: jest.fn(),
            setIndicatorStatus: jest.fn(),
            removeIndicator: jest.fn(),
            visible: false
        };

        this._settingsConnections = [];
        this._createDBusInterface();
        this._updatePosition();
    }

    disable() {
        this._settingsConnections.forEach(connection => {
            this._settings.disconnect(connection);
        });
        this._settingsConnections = [];

        if (this._widget) {
            this._widget.destroy();
            this._widget = null;
        }

        if (this._dbusImpl) {
            this._dbusImpl.unexport();
            this._dbusImpl = null;
        }

        this._settings = null;
    }

    _createDBusInterface() {
        this._dbusImpl = {
            export: jest.fn(),
            unexport: jest.fn()
        };
        this._dbusImpl.export();
    }

    _updatePosition() {
        const position = this._settings.get_string('position');

        // Remove widget from all panels first
        const panels = [Main.panel._leftBox, Main.panel._centerBox, Main.panel._rightBox];
        panels.forEach(panel => {
            const index = panel.children.indexOf(this._widget);
            if (index !== -1) {
                panel.children.splice(index, 1);
            }
        });

        // Add widget to correct panel
        if (position === 'left') {
            Main.panel._leftBox.children.push(this._widget);
        } else if (position === 'center') {
            Main.panel._centerBox.children.push(this._widget);
        } else {
            Main.panel._rightBox.children.push(this._widget);
        }
    }

    _loadIndicators() {
        if (!this._widget || !this._settings) {
            return;
        }

        const indicatorsJson = this._settings.get_string('indicators');
        const showLabels = this._settings.get_boolean('show-labels');

        let indicators = [];
        try {
            indicators = JSON.parse(indicatorsJson);
        } catch (e) {
            console.error('Failed to parse indicators configuration:', e);
            return;
        }

        this._widget.clearIndicators();
        indicators.forEach(indicator => {
            this._widget.addIndicator(
                indicator.id,
                indicator.name,
                indicator.readyIcon || '✅',
                indicator.workingIcon || '⚠️',
                indicator.waitingIcon || '⛔',
                showLabels
            );
        });
    }

    // D-Bus methods
    SetIndicatorStatus(id, status) {
        if (this._widget && id !== undefined && status !== undefined) {
            this._widget.setIndicatorStatus(id, status);
        }
    }

    AddIndicator(id, name, readyIcon = '✅', workingIcon = '⚠️', waitingIcon = '⛔') {
        if (this._widget && id !== undefined && name !== undefined) {
            const showLabels = this._settings.get_boolean('show-labels');
            this._widget.addIndicator(id, name, readyIcon, workingIcon, waitingIcon, showLabels);
        }
    }

    RemoveIndicator(id) {
        if (this._widget && id !== undefined) {
            this._widget.removeIndicator(id);
        }
    }
}

describe('StatusWidgetExtension', () => {
    let extension;
    let mockMetadata;

    beforeEach(() => {
        jest.clearAllMocks();

        // Clear panel boxes
        Main.panel._leftBox.children = [];
        Main.panel._centerBox.children = [];
        Main.panel._rightBox.children = [];

        mockMetadata = {
            uuid: 'ai-status-indicators@test',
            name: 'AI Status Indicators Test'
        };

        extension = new MockStatusWidgetExtension(mockMetadata);
    });

    describe('enable/disable lifecycle', () => {
        test('should enable extension', () => {
            extension.enable();

            expect(extension._widget).toBeDefined();
            expect(extension._settings).toBeDefined();
            expect(extension._dbusImpl).toBeDefined();
        });

        test('should disable extension', () => {
            extension.enable();
            extension.disable();

            expect(extension._widget).toBeNull();
            expect(extension._settings).toBeNull();
            expect(extension._dbusImpl).toBeNull();
        });

        test('should clean up widget on disable', () => {
            extension.enable();
            const destroySpy = extension._widget.destroy;

            extension.disable();

            expect(destroySpy).toHaveBeenCalled();
        });
    });

    describe('settings integration', () => {
        beforeEach(() => {
            extension.enable();
        });

        afterEach(() => {
            extension.disable();
        });

        test('should load indicators from settings', () => {
            const indicators = [{
                id: 'test-id',
                name: 'Test AI',
                readyIcon: '✅',
                workingIcon: '⚠️',
                waitingIcon: '⛔'
            }];

            extension._settings.set_string('indicators', JSON.stringify(indicators));
            extension._loadIndicators();

            expect(extension._widget.clearIndicators).toHaveBeenCalled();
            expect(extension._widget.addIndicator).toHaveBeenCalledWith(
                'test-id', 'Test AI', '✅', '⚠️', '⛔', false
            );
        });

        test('should handle invalid indicators JSON', () => {
            extension._settings.set_string('indicators', 'invalid json');

            // Should not throw
            expect(() => extension._loadIndicators()).not.toThrow();
        });

        test('should respect show-labels setting', () => {
            const indicators = [{
                id: 'test-id',
                name: 'Test AI',
                readyIcon: '✅',
                workingIcon: '⚠️',
                waitingIcon: '⛔'
            }];

            extension._settings.set_boolean('show-labels', true);
            extension._settings.set_string('indicators', JSON.stringify(indicators));
            extension._loadIndicators();

            expect(extension._widget.addIndicator).toHaveBeenCalledWith(
                'test-id', 'Test AI', '✅', '⚠️', '⛔', true
            );
        });
    });

    describe('settings persistence', () => {
        test('should persist indicators across disable/enable', () => {
            extension.enable();
            const indicators = [{
                id: 'persist-id',
                name: 'Persist AI',
                readyIcon: '✅',
                workingIcon: '⚠️',
                waitingIcon: '⛔'
            }];
            extension._settings.set_string('indicators', JSON.stringify(indicators));
            extension._loadIndicators();
            extension.disable();
            extension.enable();
            expect(extension._widget).toBeDefined();
            extension._loadIndicators();
            expect(extension._widget.addIndicator).toHaveBeenCalledWith(
                'persist-id', 'Persist AI', '✅', '⚠️', '⛔', false
            );
        });
    });

    describe('panel positioning', () => {
        beforeEach(() => {
            extension.enable();
        });

        afterEach(() => {
            extension.disable();
        });

        test('should position widget in right panel by default', () => {
            expect(Main.panel._rightBox.children).toContain(extension._widget);
        });

        test('should move widget to left panel', () => {
            extension._settings.set_string('position', 'left');
            extension._updatePosition();

            expect(Main.panel._leftBox.children).toContain(extension._widget);
            expect(Main.panel._rightBox.children).not.toContain(extension._widget);
        });

        test('should move widget to center panel', () => {
            extension._settings.set_string('position', 'center');
            extension._updatePosition();

            expect(Main.panel._centerBox.children).toContain(extension._widget);
            expect(Main.panel._rightBox.children).not.toContain(extension._widget);
        });
    });

    describe('D-Bus interface', () => {
        beforeEach(() => {
            extension.enable();
        });

        afterEach(() => {
            extension.disable();
        });

        test('should create D-Bus interface on enable', () => {
            expect(extension._dbusImpl).toBeDefined();
        });

        test('should export D-Bus interface', () => {
            expect(extension._dbusImpl.export).toHaveBeenCalled();
        });

        test('should unexport D-Bus interface on disable', () => {
            const unexportSpy = extension._dbusImpl.unexport;

            extension.disable();

            expect(unexportSpy).toHaveBeenCalled();
        });
    });

    describe('D-Bus methods', () => {
        beforeEach(() => {
            extension.enable();
        });

        afterEach(() => {
            extension.disable();
        });

        test('should set indicator status', () => {
            extension.SetIndicatorStatus('test-id', 'working');

            expect(extension._widget.setIndicatorStatus).toHaveBeenCalledWith('test-id', 'working');
        });

        test('should add indicator', () => {
            extension.AddIndicator('test-id', 'Test AI', '✅', '⚠️', '⛔');

            expect(extension._widget.addIndicator).toHaveBeenCalledWith(
                'test-id', 'Test AI', '✅', '⚠️', '⛔', false
            );
        });

        test('should remove indicator', () => {
            extension._widget.removeIndicator = jest.fn();

            extension.RemoveIndicator('test-id');

            expect(extension._widget.removeIndicator).toHaveBeenCalledWith('test-id');
        });

        test('should handle D-Bus calls when widget is null', () => {
            extension._widget = null;

            // Should not throw
            expect(() => extension.SetIndicatorStatus('test-id', 'working')).not.toThrow();
            expect(() => extension.AddIndicator('test-id', 'Test AI')).not.toThrow();
            expect(() => extension.RemoveIndicator('test-id')).not.toThrow();
        });
    });

    describe('D-Bus parameter validation', () => {
        beforeEach(() => {
            extension.enable();
        });
        afterEach(() => {
            extension.disable();
        });
        test('should handle missing arguments in D-Bus methods', () => {
            expect(() => extension.SetIndicatorStatus()).not.toThrow();
            expect(() => extension.AddIndicator()).not.toThrow();
            expect(() => extension.RemoveIndicator()).not.toThrow();
        });
    });

    describe('panel positioning edge cases', () => {
        beforeEach(() => {
            extension.enable();
        });
        afterEach(() => {
            extension.disable();
        });
        test('should handle invalid position value', () => {
            extension._settings.set_string('position', 'invalid');
            expect(() => extension._updatePosition()).not.toThrow();
            // Should default to right panel
            expect(Main.panel._rightBox.children).toContain(extension._widget);
        });
    });

    describe('error handling', () => {
        test('should handle enable errors gracefully', () => {
            // Mock a failure in getSettings
            const originalGetSettings = Extension.prototype.getSettings;
            Extension.prototype.getSettings = jest.fn().mockImplementation(() => {
                throw new Error('Settings error');
            });

            expect(() => extension.enable()).toThrow();

            // Restore
            Extension.prototype.getSettings = originalGetSettings;
        });

        test('should handle disable when not enabled', () => {
            expect(() => extension.disable()).not.toThrow();
        });
    });
});
