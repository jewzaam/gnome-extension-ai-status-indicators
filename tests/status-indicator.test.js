// Generated by Cursor
// Unit tests for StatusIndicator class
// Need to mock the module imports since we can't directly import ES6 modules with GNOME Shell imports

// Mock the required modules
const GObject = global.imports.gi.GObject;
const St = global.imports.gi.St;

// Create a simplified version of StatusIndicator for testing
class StatusIndicator extends St.BoxLayout {
    constructor(name, readyIcon, workingIcon, waitingIcon, showLabel) {
        super({
            style_class: 'status-indicator',
            reactive: true,
            can_focus: true,
            track_hover: true,
            vertical: false
        });

        this._name = name;
        this._readyIcon = readyIcon;
        this._workingIcon = workingIcon;
        this._waitingIcon = waitingIcon;
        this._showLabel = showLabel;
        this._status = 'ready';

        this._iconLabel = new St.Label({
            text: this._readyIcon,
            y_align: St.Align.MIDDLE,
            style_class: 'status-indicator-icon'
        });

        this.add_child(this._iconLabel);

        if (this._showLabel) {
            this._textLabel = new St.Label({
                text: this._name,
                y_align: St.Align.MIDDLE,
                style_class: 'status-indicator-label'
            });
            this.add_child(this._textLabel);
        }
    }

    setStatus(status) {
        this._status = status;
        let icon;
        switch (status) {
            case 'working':
                icon = this._workingIcon;
                break;
            case 'waiting':
                icon = this._waitingIcon;
                break;
            case 'ready':
            default:
                icon = this._readyIcon;
                break;
        }
        this._iconLabel.set_text(icon);
    }

    setWorking(isWorking) {
        this.setStatus(isWorking ? 'working' : 'ready');
    }

    updateConfig(name, readyIcon, workingIcon, waitingIcon, showLabel) {
        this._name = name;
        this._readyIcon = readyIcon;
        this._workingIcon = workingIcon;
        this._waitingIcon = waitingIcon;
        
        this.setStatus(this._status);
        
        if (this._showLabel !== showLabel) {
            this._showLabel = showLabel;
            if (showLabel && !this._textLabel) {
                this._textLabel = new St.Label({
                    text: this._name,
                    y_align: St.Align.MIDDLE,
                    style_class: 'status-indicator-label'
                });
                this.add_child(this._textLabel);
            } else if (!showLabel && this._textLabel) {
                this.remove_child(this._textLabel);
                this._textLabel = null;
            }
        }
        
        if (this._textLabel) {
            this._textLabel.set_text(this._name);
        }
    }
}

describe('StatusIndicator', () => {
    let indicator;

    beforeEach(() => {
        // Reset mocks
        jest.clearAllMocks();
        
        // Create a new indicator for each test
        indicator = new StatusIndicator('Test AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', false);
    });

    describe('initialization', () => {
        test('should create indicator with correct initial state', () => {
            expect(indicator._name).toBe('Test AI');
            expect(indicator._readyIcon).toBe('‚úÖ');
            expect(indicator._workingIcon).toBe('‚ö†Ô∏è');
            expect(indicator._waitingIcon).toBe('‚õî');
            expect(indicator._status).toBe('ready');
            expect(indicator._showLabel).toBe(false);
        });

        test('should show ready icon initially', () => {
            expect(indicator._iconLabel.text).toBe('‚úÖ');
        });

        test('should create text label when showLabel is true', () => {
            const indicatorWithLabel = new StatusIndicator('Test AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', true);
            expect(indicatorWithLabel._textLabel).toBeDefined();
            expect(indicatorWithLabel._textLabel.text).toBe('Test AI');
        });

        test('should not create text label when showLabel is false', () => {
            expect(indicator._textLabel).toBeUndefined();
        });
    });

    describe('setStatus', () => {
        test('should change to working status', () => {
            indicator.setStatus('working');
            expect(indicator._status).toBe('working');
            expect(indicator._iconLabel.text).toBe('‚ö†Ô∏è');
        });

        test('should change to waiting status', () => {
            indicator.setStatus('waiting');
            expect(indicator._status).toBe('waiting');
            expect(indicator._iconLabel.text).toBe('‚õî');
        });

        test('should change to ready status', () => {
            indicator.setStatus('working');
            indicator.setStatus('ready');
            expect(indicator._status).toBe('ready');
            expect(indicator._iconLabel.text).toBe('‚úÖ');
        });

        test('should default to ready for unknown status', () => {
            indicator.setStatus('unknown');
            expect(indicator._status).toBe('unknown');
            expect(indicator._iconLabel.text).toBe('‚úÖ');
        });
    });

    describe('setWorking (backward compatibility)', () => {
        test('should set working status when true', () => {
            indicator.setWorking(true);
            expect(indicator._status).toBe('working');
            expect(indicator._iconLabel.text).toBe('‚ö†Ô∏è');
        });

        test('should set ready status when false', () => {
            indicator.setWorking(false);
            expect(indicator._status).toBe('ready');
            expect(indicator._iconLabel.text).toBe('‚úÖ');
        });
    });

    describe('updateConfig', () => {
        test('should update icons and name', () => {
            indicator.updateConfig('New AI', 'üü¢', 'üü°', 'üî¥', false);
            
            expect(indicator._name).toBe('New AI');
            expect(indicator._readyIcon).toBe('üü¢');
            expect(indicator._workingIcon).toBe('üü°');
            expect(indicator._waitingIcon).toBe('üî¥');
            expect(indicator._iconLabel.text).toBe('üü¢'); // Should show ready icon
        });

        test('should update display when status changes', () => {
            indicator.setStatus('working');
            indicator.updateConfig('New AI', 'üü¢', 'üü°', 'üî¥', false);
            
            expect(indicator._iconLabel.text).toBe('üü°'); // Should show working icon
        });

        test('should add text label when showLabel changes to true', () => {
            expect(indicator._textLabel).toBeUndefined();
            
            indicator.updateConfig('New AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', true);
            
            expect(indicator._textLabel).toBeDefined();
            expect(indicator._textLabel.text).toBe('New AI');
        });

        test('should remove text label when showLabel changes to false', () => {
            // First create indicator with label
            const indicatorWithLabel = new StatusIndicator('Test AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', true);
            expect(indicatorWithLabel._textLabel).toBeDefined();
            
            // Then update to remove label
            indicatorWithLabel.updateConfig('Test AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', false);
            
            expect(indicatorWithLabel._textLabel).toBeNull();
        });

        test('should update text label content when name changes', () => {
            const indicatorWithLabel = new StatusIndicator('Test AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', true);
            
            indicatorWithLabel.updateConfig('Updated AI', '‚úÖ', '‚ö†Ô∏è', '‚õî', true);
            
            expect(indicatorWithLabel._textLabel.text).toBe('Updated AI');
        });
    });

    describe('status transitions', () => {
        test('should handle complete status cycle', () => {
            // Start ready
            expect(indicator._iconLabel.text).toBe('‚úÖ');
            
            // Go to working
            indicator.setStatus('working');
            expect(indicator._iconLabel.text).toBe('‚ö†Ô∏è');
            
            // Go to waiting
            indicator.setStatus('waiting');
            expect(indicator._iconLabel.text).toBe('‚õî');
            
            // Back to ready
            indicator.setStatus('ready');
            expect(indicator._iconLabel.text).toBe('‚úÖ');
        });
    });
}); 