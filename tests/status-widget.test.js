// Generated by Cursor
// Unit tests for StatusWidget class
const St = global.imports.gi.St;
const PanelMenu = global.PanelMenu;
const _ = global._;

// Mock StatusIndicator class for testing
class MockStatusIndicator {
    constructor(name, readyIcon, workingIcon, waitingIcon, showLabel) {
        this._name = name;
        this._readyIcon = readyIcon;
        this._workingIcon = workingIcon;
        this._waitingIcon = waitingIcon;
        this._showLabel = showLabel;
        this._status = 'ready';
    }

    setStatus(status) {
        this._status = status;
    }

    setWorking(isWorking) {
        this._status = isWorking ? 'working' : 'ready';
    }

    updateConfig(name, readyIcon, workingIcon, waitingIcon, showLabel) {
        this._name = name;
        this._readyIcon = readyIcon;
        this._workingIcon = workingIcon;
        this._waitingIcon = waitingIcon;
        this._showLabel = showLabel;
    }
}

// Create a simplified version of StatusWidget for testing
class StatusWidget extends PanelMenu.Button {
    constructor() {
        super(0.0, _('AI Status Indicators'));

        this._container = new St.BoxLayout({
            style_class: 'status-widget-container',
            vertical: false
        });

        this.add_child(this._container);
        this._indicators = new Map();
        this._updateVisibility();
    }

    addIndicator(id, name, readyIcon = '✅', workingIcon = '⚠️', waitingIcon = '⛔', showLabel = false) {
        if (this._indicators.has(id)) {
            return;
        }

        const indicator = new MockStatusIndicator(name, readyIcon, workingIcon, waitingIcon, showLabel);
        this._indicators.set(id, indicator);
        this._container.add_child(indicator);
        this._updateVisibility();
    }

    removeIndicator(id) {
        const indicator = this._indicators.get(id);
        if (indicator) {
            this._container.remove_child(indicator);
            this._indicators.delete(id);
            this._updateVisibility();
        }
    }

    updateIndicator(id, name, readyIcon, workingIcon, waitingIcon, showLabel) {
        const indicator = this._indicators.get(id);
        if (indicator) {
            indicator.updateConfig(name, readyIcon, workingIcon, waitingIcon, showLabel);
        }
    }

    setIndicatorStatus(id, status) {
        const indicator = this._indicators.get(id);
        if (indicator) {
            if (typeof status === 'boolean') {
                indicator.setWorking(status);
            } else {
                indicator.setStatus(status);
            }
        }
    }

    clearIndicators() {
        for (const [, indicator] of this._indicators) {
            this._container.remove_child(indicator);
        }
        this._indicators.clear();
        this._updateVisibility();
    }

    _updateVisibility() {
        this.visible = this._indicators.size > 0;
    }
}

describe('StatusWidget', () => {
    let widget;

    beforeEach(() => {
        jest.clearAllMocks();
        widget = new StatusWidget();
    });

    describe('initialization', () => {
        test('should create widget with empty indicators map', () => {
            expect(widget._indicators.size).toBe(0);
        });

        test('should be invisible when no indicators', () => {
            expect(widget.visible).toBe(false);
        });

        test('should have container with correct style class', () => {
            expect(widget._container.style_class).toBe('status-widget-container');
        });
    });

    describe('addIndicator', () => {
        test('should add indicator with default values', () => {
            widget.addIndicator('test-id', 'Test AI');

            expect(widget._indicators.size).toBe(1);
            expect(widget._indicators.has('test-id')).toBe(true);
            expect(widget.visible).toBe(true);
        });

        test('should add indicator with custom icons', () => {
            widget.addIndicator('test-id', 'Test AI', '🟢', '🟡', '🔴', false);

            const indicator = widget._indicators.get('test-id');
            expect(indicator._readyIcon).toBe('🟢');
            expect(indicator._workingIcon).toBe('🟡');
            expect(indicator._waitingIcon).toBe('🔴');
        });

        test('should not add duplicate indicator', () => {
            widget.addIndicator('test-id', 'Test AI');
            widget.addIndicator('test-id', 'Test AI 2');

            expect(widget._indicators.size).toBe(1);
        });

        test('should add indicator to container', () => {
            widget.addIndicator('test-id', 'Test AI');

            expect(widget._container.children.length).toBe(1);
        });

        test('should make widget visible when first indicator added', () => {
            expect(widget.visible).toBe(false);

            widget.addIndicator('test-id', 'Test AI');

            expect(widget.visible).toBe(true);
        });
    });

    describe('removeIndicator', () => {
        beforeEach(() => {
            widget.addIndicator('test-id', 'Test AI');
        });

        test('should remove existing indicator', () => {
            expect(widget._indicators.size).toBe(1);

            widget.removeIndicator('test-id');

            expect(widget._indicators.size).toBe(0);
            expect(widget._indicators.has('test-id')).toBe(false);
        });

        test('should remove indicator from container', () => {
            expect(widget._container.children.length).toBe(1);

            widget.removeIndicator('test-id');

            expect(widget._container.children.length).toBe(0);
        });

        test('should make widget invisible when last indicator removed', () => {
            expect(widget.visible).toBe(true);

            widget.removeIndicator('test-id');

            expect(widget.visible).toBe(false);
        });

        test('should handle removing non-existent indicator', () => {
            widget.removeIndicator('non-existent');

            expect(widget._indicators.size).toBe(1);
        });
    });

    describe('updateIndicator', () => {
        beforeEach(() => {
            widget.addIndicator('test-id', 'Test AI');
        });

        test('should update existing indicator', () => {
            widget.updateIndicator('test-id', 'Updated AI', '🟢', '🟡', '🔴', true);

            const indicator = widget._indicators.get('test-id');
            expect(indicator._name).toBe('Updated AI');
            expect(indicator._readyIcon).toBe('🟢');
            expect(indicator._workingIcon).toBe('🟡');
            expect(indicator._waitingIcon).toBe('🔴');
            expect(indicator._showLabel).toBe(true);
        });

        test('should handle updating non-existent indicator', () => {
            widget.updateIndicator('non-existent', 'Test', '✅', '⚠️', '⛔', false);

            expect(widget._indicators.size).toBe(1);
        });
    });

    describe('setIndicatorStatus', () => {
        beforeEach(() => {
            widget.addIndicator('test-id', 'Test AI');
        });

        test('should set status with string value', () => {
            widget.setIndicatorStatus('test-id', 'working');

            const indicator = widget._indicators.get('test-id');
            expect(indicator._status).toBe('working');
        });

        test('should set status with boolean value (backward compatibility)', () => {
            widget.setIndicatorStatus('test-id', true);

            const indicator = widget._indicators.get('test-id');
            expect(indicator._status).toBe('working');
        });

        test('should handle setting status on non-existent indicator', () => {
            widget.setIndicatorStatus('non-existent', 'working');

            // Should not throw error
            expect(widget._indicators.size).toBe(1);
        });
    });

    describe('clearIndicators', () => {
        beforeEach(() => {
            widget.addIndicator('test-1', 'Test AI 1');
            widget.addIndicator('test-2', 'Test AI 2');
            widget.addIndicator('test-3', 'Test AI 3');
        });

        test('should remove all indicators', () => {
            expect(widget._indicators.size).toBe(3);

            widget.clearIndicators();

            expect(widget._indicators.size).toBe(0);
        });

        test('should clear container', () => {
            expect(widget._container.children.length).toBe(3);

            widget.clearIndicators();

            expect(widget._container.children.length).toBe(0);
        });

        test('should make widget invisible', () => {
            expect(widget.visible).toBe(true);

            widget.clearIndicators();

            expect(widget.visible).toBe(false);
        });
    });

    describe('multiple indicators', () => {
        test('should handle multiple indicators', () => {
            widget.addIndicator('cursor', 'Cursor AI');
            widget.addIndicator('copilot', 'Copilot');
            widget.addIndicator('claude', 'Claude');

            expect(widget._indicators.size).toBe(3);
            expect(widget._container.children.length).toBe(3);
            expect(widget.visible).toBe(true);
        });

        test('should independently control multiple indicators', () => {
            widget.addIndicator('cursor', 'Cursor AI');
            widget.addIndicator('copilot', 'Copilot');

            widget.setIndicatorStatus('cursor', 'working');
            widget.setIndicatorStatus('copilot', 'waiting');

            expect(widget._indicators.get('cursor')._status).toBe('working');
            expect(widget._indicators.get('copilot')._status).toBe('waiting');
        });
    });

    describe('visibility management', () => {
        test('should be invisible with no indicators', () => {
            expect(widget.visible).toBe(false);
        });

        test('should be visible with one indicator', () => {
            widget.addIndicator('test-id', 'Test AI');
            expect(widget.visible).toBe(true);
        });

        test('should remain visible when removing one of multiple indicators', () => {
            widget.addIndicator('test-1', 'Test AI 1');
            widget.addIndicator('test-2', 'Test AI 2');

            widget.removeIndicator('test-1');

            expect(widget.visible).toBe(true);
        });

        test('should become invisible when removing last indicator', () => {
            widget.addIndicator('test-id', 'Test AI');

            widget.removeIndicator('test-id');

            expect(widget.visible).toBe(false);
        });
    });
});
